introduction-to-the-core
========================

内容
##1.libVLC的介绍
##2.VLC的通道和模块
##2.1VLC中的模块
##3.线程管理
  3.1线程
##3.2互斥( (vlc_mutex_t)
  3.3条件变量（vlc_cond_t）
  3.4其他
  3.5 原子变量
##4.同步
 4.1警告
5.核心源代码的详细信息
1.libVLC的介绍
  VLC媒体播放器的核心称为libVLC。
  它主要管理VLC的线程，模块部分（编解码器，分路器等）以及它的层，时钟，播放列表和所有低级别的控制。例如：它负责管理所有的音频，视频和字幕轨之间的同步。libVLC位于libVLCcore的顶端，用以允许外部应用程序生成器来使用核心的功能。而模块则与libVLCcore相连接，其是相对与libVLCcore建立起来的，而外部应用则是相对与libVLC建立起来的。
2.VLC的通道和模块
  在VLC中，一个主要的概念是“模块化”。
  事实上，VLC是一个你可以根据需要动态地加载许多插件和模块的完整的多媒体框架（例如DirectShow和GStreamer）。其核心框架是用来做从输入（文件，网络流）到输出（音频或视频，在ascreen或网络）的“接线”和媒体处理，而在每一个阶段的大部分工作是由各种模块完成的（各种muxers，分路器，解码器，过滤器和输出）。甚至接口也是VLC的一个插件。
  2.1VLC中的模块
  在源代码中，模块一般位于modules/ subdirectory. 在每一阶段的通道，VLC使用那些模块做大部分的工作。而模块是根据工作时的必要性加载的（参考VLC模块的加载机制）。每个模块提供适合某一特定用途的情况下，或一个特定的环境的不同的功能。此外，模块的可移植性导致使用于特定平台的audio_output/video_output/interface的写入。而插件模块的动态加载与卸载是由src/modules/modules.c实现此功能的。此外，模块也可以使用libVLC直接内置到应用程序中，例如VLC在不支持动态加载代码的操作系统时，它们被称为内建命令。
3.线程管理
  3.1VLC采用多线程管理模式。单线程的方式将引入更多的复杂性，特别是由于解码器的调度，例如解码器和输出必须分开，否则不能保证某一帧能在特定的时候被播放。多进程的方式也没有选择，因为多进程的解码器通常意味着更多的占用资源和进程之间的通信（共享内存的问题）更难。
VLC的线程结构是仿照POSIX线程（pthread的）。然而，由于可移植性的原因，VLC不直接使用pthread_功能，但有类似的自定义的API集。
Threads (vlc_thread_t)
    vlc_clone() 产生一个线程.
    vlc_join() 等待一个线程终止并释放资源
  3.2互斥
Mutual exclusion (vlc_mutex_t) 
    vlc_mutex_init() 创建一个非递归的互斥锁.
    vlc_mutex_init_recursive() 创建一个递归互斥体(discouraged).
    vlc_mutex_lock() 锁定一个互斥体，如果需要的话等待.
    vlc_mutex_trylock() 锁定一个互斥体，如果它不是已经被锁定，否则返回一个错误.
    vlc_mutex_unlock() 释放一个互斥体.
    vlc_mutex_destroy() 破坏一个互斥. 
3.3条件变量
Condition variable (vlc_cond_t)
    vlc_cond_init() 创建一个条件变量使用的单调时钟（mdate（）），用于超时.
    vlc_cond_init_daytime() 创建一个使用realtime clock / wall clock的条件变量，用于超时.
    vlc_cond_signal() 信号的一个线程，用于等待一个条件变量
    vlc_cond_broadcast() 信号的都在等待一个条件变量的所有线程.
    vlc_cond_wait() 等待一个条件变量发出信号（也可以唤醒不合逻辑）.
    vlc_cond_timedwait() 在一定超时等待一个条件变量发出信号（还可以唤醒不合逻辑）.
    vlc_cond_destroy() 破坏一个条件变量.
3.4其他
VLC也有用于小的读/写锁，自旋锁，线程特定的变量，类似于POSIX线程的抽象。
3.5原子变量
原子变量是一个可以从多个线程获得，而无需锁定操作（如sizeof（void *）的）的值。请参阅include/ vlc_atomic.h（说明支持操作的列表）。
4.同步
VLC的另一个重要特点是，解码和播放是异步的：解码是由解码器线程完成的，而播放是由audio_output or video_output线程完成的。设计的目标是确保正好在合适的时间播放音频或视频帧，而不阻止任何的解码器线程。这就导致一个接口，输入，解码器和输出之间复杂的通信结构。
理论上，一些输入和video_output线程同时读取多个文件是允许的，尽管事实上，目前接口不允许任何办法做到这一点，但在不久的将来，可能会有变化。但无论如何，从一开始就考虑到这一点时客户端已被写入。这还意味着，在不使用一个全局锁的前提下，一个非折返库（包括特别的liba52）不能被使用。
位于流的系统层的显示标记时间被传送到解码器和所有想对应的时间产生的采样，而输出层要在正确的时间显示它们。日期将会被转换到微秒，而一个绝对的日期是自纪元（1970年1月1日）的微秒数。mtime_t类型是一个有符号的64位整数。
此外，当前的日期，可以检索用mdate（）。而一个线程的执行可以被暂停，直到一个特定的时间到来(mtime_t date)。当然，你也可以通过msleep延时一个固定的微秒数( mtime_t delay ). 
4.1警告
如果需要做一些特定的操作时（比如色度变换），一定要记着在presentation date之前唤醒。例如在modules/codec/libmpeg2.c中，轨道的平均解码时间需要被保持，以确保图像解码不会延迟。
5.核心源代码的详细信息
所有的libVLC的源文件都位于src/ directory以及它到子目录中。
    audio_output /：初始化音频调音台，即。发现正确的播放频率，然后重新取样从解码器（）接收到的音频帧。
    config/：命令行和配置文件加载配置，提供的功能的模块读取和写入配置
    control/控制的行为的libVLCcore中，如播放/暂停，音量管理，全屏，日志级​​别等功能
    extras/：主要是特定于平台的代码
    input/输入模块，读取数据包，分析，并通过重组基本流解码器（S）*模块/模块管理
    interface/：包含与用户进行交互，如按键和设备弹出的代码。
    MISC /：在libvlc的其他部分使用的各种工具，如线程系统，消息队列，CPU检测，对象查询系统，或特定于平台的代码。
    modules/模块管理
    network/网络接口（socket管理，网络错误等）
    OSD /：屏幕显示操作
    playlist/管理播放列表，如停止，播放，下一个，或随机播放的互动。
    stream_output /流音频和视频的网络功能
    test/：libVLC需要进行测试，而不是只由用户:)
    text/字符集的东西
    video_output /：初始化视频显示，得到所有的图片和从解码器（）的子图像（即字幕），任选地将它们转换为另一种格式（例如，YUV到RGB），并显示它们
 














